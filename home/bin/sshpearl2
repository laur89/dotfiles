#!/usr/bin/env bash

KYRAT_SHELL=${KYRAT_SHELL:-bash}

BASE64=base64
BASH=bash
ZSH=zsh
SH=sh
CAT=cat
GUNZIP=gunzip
GZIP=gzip
SSH=ssh
# PATH needs to be updated since GNU Coreutils is required in OSX environments
GNUBIN='/usr/local/opt/coreutils/libexec/gnubin'

NOT_EXISTING_COMMAND=111
NO_WRITABLE_DIRECTORY=112
KYRAT_SHELL_NOT_CORRECT=113

readonly SELF="$(basename -- "$0")"
PEARL_HOME=${PEARL_HOME:-$HOME/.config/pearl}

# strip empty lines & comments from input ($1) file
_process_rc_file() {
    sed '/^\s*#/ d;/^\s*$/d' < "$1"
}

#######################################
# Concatenate files to standard output.
#
# Globals:
#   None
# Arguments:
#   files ($@)  :  the program arguments.
# Returns:
#   None
# Output:
#   The file contents.
#######################################

# pass rc files or directories containing rc files as separate arguments.
# TODO: pass comment initiator (eg. # vs ") as an arg?
_concatenate_files() {
    local node i

    # strip empty lines & comments:
    for node in "$@"; do
        [[ -e "$node" ]] || continue
        if [[ -f "$node" ]]; then
            _process_rc_file "$node"
        elif [[ -d "$node" ]]; then
            for i in "$node"/*; do
                [[ -f "$i" ]] || continue
                _process_rc_file "$i"
            done
        fi
    done
}

#######################################
# Run ssh session with all config files
# in $KYRAT_HOME.
#
# Globals:
#   KYRAT_HOME (RO)  : Kyrat home location.
#   BASE64 (RO)      : base64 command.
#   GZIP (RO)        : gzip command.
#   GUNZIP (RO)      : gunzip command.
# Arguments:
#   args ($@)        : The ssh arguments.
# Returns:
#   None
# Output:
#   None
#######################################
kyrat() {
    #mkdir -p "$KYRAT_HOME/bashrc.d"
    #mkdir -p "$KYRAT_HOME/zshrc.d"
    #mkdir -p "$KYRAT_HOME/inputrc.d"
    #mkdir -p "$KYRAT_HOME/vimrc.d"
    #mkdir -p "$KYRAT_HOME/tmux.conf.d"
    _parse_args "$@"
    _execute_ssh
}

#######################################
# Parse the ssh arguments.
#
# Globals:
#   SSH (RO)         : ssh command.
#   SSH_OPTS (WO)    : The ssh options.
#   COMMANDS (WO)    : The ssh command to invoke remotely.
# Arguments:
#   args ($@)        : The ssh arguments.
# Returns:
#   None
# Output:
#   None
#######################################
_parse_args() {
    local opt

    [[ -z "$*" ]] && { $SSH; exit $?; }

    SSH_OPTS=()
    for opt in "$@"; do
        case "$opt" in
            --) shift; break ;;
            *) SSH_OPTS+=("$opt"); shift ;;
        esac
    done

    COMMANDS=("$@")
}

#######################################
# Run ssh session with all config files
# in $KYRAT_HOME.
#
# Globals:
#   KYRAT_HOME (RO)      : Kyrat home location.
#   BASE64 (RO)          : base64 command.
#   GZIP (RO)            : gzip command.
#   GUNZIP (RO)          : gunzip command.
# Arguments:
#   args ($@)            : The ssh arguments.
# Returns:
#   NOT_EXISTING_COMMAND : if one of the required commands
#                          does not exist.
# Output:
#   None
#######################################
_execute_ssh() {
    command -v $BASE64 >/dev/null 2>&1 || { echo >&2 "kyrat requires $BASE64 to be installed locally. Aborting."; return $NOT_EXISTING_COMMAND; }
    command -v $GZIP >/dev/null 2>&1 || { echo >&2 "kyrat requires $GZIP to be installed locally. Aborting."; return $NOT_EXISTING_COMMAND; }
    if [[ $KYRAT_SHELL != "$BASH" && $KYRAT_SHELL != "$ZSH" && $KYRAT_SHELL != "$SH" ]]; then
        echo >&2 "KYRAT_SHELL not set correctly: $KYRAT_SHELL. Aborting.";
        return $KYRAT_SHELL_NOT_CORRECT;
    fi

    local remote_command="$(_get_remote_command)"

    #$SSH -t "${SSH_OPTS[@]}" -- "$BASH -c '$remote_command'"  # TODO: upstream version, doesn't work
    $SSH -t "${SSH_OPTS[@]}" -- "$remote_command"
}

#######################################
# Compose and return the remote command
# to be executed inside the ssh session.
#
# Globals:
#   KYRAT_HOME (RO)       : Kyrat home location.
#   BASE64 (RO)           : base64 command.
#   GZIP (RO)             : gzip command.
#   GUNZIP (RO)           : gunzip command.
#   COMMANDS (RO?)        : ssh commands to execute (if any).
# Arguments:
#   None
# Returns:
#   NOT_EXISTING_COMMAND  : if one of the required commands
#                           does not exist.
#   NO_WRITABLE_DIRECTORY : if no writable directories could
#                           be found in the remote host.
# Output:
#   The composed remote command to execute in the ssh session.
#######################################
_get_remote_command() {
    local bashrc_script="$(_concatenate_files "$PEARL_HOME"/bashrc "$PEARL_HOME"/bashrc.d | $GZIP | $BASE64)"
    local zshrc_script="$(_concatenate_files "$PEARL_HOME"/zshrc "$PEARL_HOME"/zshrc.d | $GZIP | $BASE64)"
    local inputrc_script="$(_concatenate_files "$PEARL_HOME"/inputrc "$PEARL_HOME"/inputrc.d | $GZIP | $BASE64)"
    local vimrc_script="$(_concatenate_files "$PEARL_HOME"/vimrc "$PEARL_HOME"/vimrc.d | $GZIP | $BASE64)"
    local tmux_conf="$(_concatenate_files "$PEARL_HOME"/tmux.conf "$PEARL_HOME"/tmux.conf.d | $GZIP | $BASE64)"
    self="$($GZIP < "$0" | $BASE64)"

    if [[ $KYRAT_SHELL == "$BASH" ]]; then
        KYRAT_SHELL_CMD="$BASH --rcfile \${PEARL_HOME}/bashrc -i"
    elif [[ $KYRAT_SHELL == "$ZSH" ]]; then
        KYRAT_SHELL_CMD="$ZSH -i"
    elif [[ $KYRAT_SHELL == "$SH" ]]; then
        KYRAT_SHELL_CMD="$SH -i"
    fi

    $CAT <<EOF
[[ -d "$GNUBIN" ]] && PATH="$GNUBIN:\$PATH";
unset _tmp_dir; for d in /tmp \$HOME; do [[ -w "\$d" ]] && { _tmp_dir="\$d"; break; } done;
[[ -d "\$_tmp_dir" ]] || { echo >&2 "couldn't find writable tempdirs on the server. Aborting."; exit $NO_WRITABLE_DIRECTORY; };
for d in $BASE64 $GUNZIP mktemp; do command -v "\$d" >/dev/null 2>&1 || { echo >&2 "pearl-ssh requires [\$d] to be installed on the server. Aborting."; exit $NOT_EXISTING_COMMAND; } done;

export PEARL_HOME="\$(mktemp -d pearl-XXXXX -p "\$_tmp_dir")";
PEARLSSH_BIN="\$PEARL_HOME/bin"; mkdir -- "\$PEARLSSH_BIN";
export _TMUX_RC="\$_tmp_dir/.laur_tmux_rc";
rm -rf -- "\$_TMUX_RC" 2>/dev/null; mkdir -- "\$_TMUX_RC";

trap "rm -rf -- '\$PEARL_HOME'; exit" EXIT HUP INT QUIT PIPE TERM KILL;
EOF

    if [[ -n "${COMMANDS[*]}" ]]; then
        local commands_opt="-c '${COMMANDS[*]}'"
#    else
#        $CAT <<EOF
#[[ -e /etc/motd ]] && $CAT /etc/motd || { [[ -e /etc/update-motd.d ]] && command -v run-parts &> /dev/null && run-parts /etc/update-motd.d/; }
#EOF
    fi

    $CAT <<EOF
echo "${bashrc_script}" | $BASE64 -di | $GUNZIP > "\${PEARL_HOME}/bashrc";
echo "${zshrc_script}" | $BASE64 -di | $GUNZIP > "\${PEARL_HOME}/.zshrc";
echo "${inputrc_script}" | $BASE64 -di | $GUNZIP > "\${PEARL_HOME}/inputrc";
echo "${vimrc_script}" | $BASE64 -di | $GUNZIP > "\${PEARL_HOME}/vimrc";
echo "${tmux_conf}" | $BASE64 -di | $GUNZIP > "\${PEARL_HOME}/tmux.conf";

echo "$self" | $BASE64 -di | $GUNZIP > "\$PEARLSSH_BIN/$SELF";

# TODO: import more bins!!!!!!!!!!!!!!!!!!!!!!!!
chmod -R +x "\$PEARLSSH_BIN";

export PATH="\$PATH:\$PEARLSSH_BIN";

# from here on only my changes compared to upstream kyrat: {{{

# increments the number of dashes to be used in PS1 env var to indicate
# the ssh-ing depth, as in how deep in ssh-sessions are we:
export _SSH_PEARL_DEPTH_DASHES=${_SSH_PEARL_DEPTH_DASHES}-

if ! grep -q 'pearl-ssh local function additions.*overrides' "\$PEARL_HOME/bashrc"; then
    echo -e "# pearl-ssh local function additions/overrides:\\nunalias gosu tmux >/dev/null 2>&1" >> "\$PEARL_HOME/bashrc"
fi

# delete previous (as in the one inherited from the previous ssh session) gosu() function definition:
sed -i '/^gosu().*VIMINIT.*INPUTRC.*bash/d' "\$PEARL_HOME/bashrc"


sed -i '/^alias tmux=/d' "\$PEARL_HOME/bashrc"
# enter new tmux alias (keep on a single line!):
echo -e "alias tmux='tmux -f \"\$_TMUX_RC/tmux.conf\"'" >> "\$PEARL_HOME/bashrc"
sed -i '/^set .* default-command /d' "\$PEARL_HOME/tmux.conf"
echo -e "set -g default-command \"VIMINIT='let \\\$MYVIMRC=\$_TMUX_RC/vimrc | source \\\$MYVIMRC' INPUTRC='\$_TMUX_RC/inputrc' /bin/bash --rcfile '\$_TMUX_RC/bashrc'\"" >> "\$PEARL_HOME/tmux.conf"
cp -rp -- "\$PEARL_HOME"/* "\$_TMUX_RC/"

# enter new gosu() function def (keep on a single line!):
for d in \$PEARL_HOME \$_TMUX_RC; do echo -e "gosu() { sudo -E bash --rcfile \"\$d/bashrc\" -i $commands_opt; }" >> "\$d/bashrc"; done

# doctor tmux settings/configs:
[[ :\$PATH: != *:"\$_TMUX_RC/bin":* ]] && export PATH=\$PATH:\$_TMUX_RC/bin;  # make sure to keep _TMUX_RC at the _bottom_ of PATH

# we used to export these instead of prepending to bash cmd:
#export VIMINIT="let \\\$MYVIMRC='\$PEARL_HOME/vimrc' | source \\\$MYVIMRC"
#export INPUTRC="\$PEARL_HOME/inputrc"
# }}} /my-changes

VIMINIT="let \\\$MYVIMRC='\${PEARL_HOME}/vimrc' | source \\\$MYVIMRC" INPUTRC="\${PEARL_HOME}/inputrc" TMUX_CONF="\${PEARL_HOME}/tmux.conf" \
PEARL_HOME="\${PEARL_HOME}" ZDOTDIR="\${PEARL_HOME}" ${KYRAT_SHELL_CMD} ${commands_opt};
EOF
}

kyrat "$@"
