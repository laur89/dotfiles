#!/bin/bash
# handles basic system startup.
# note that services to be started are handled by different file, imported here.
#
# this file is launched/sourced by .xinputrc
#
# according to https://wiki.archlinux.org/index.php/Xinit#Starting_applications_without_a_window_manager,
# this file should *at least* contain the last block of /etc/X11/xinit/xinitrc
##################################

SESSION_STARTFILE="$HOME/.session-startuplist"
declare -a AUTOSTART=()
_SELF=".common_startup"
################################################

#### ENTRY ####
# import common:
if ! type __COMMONS_LOADED_MARKER > /dev/null 2>&1; then
    if [[ -r "$_SCRIPTS_COMMONS" ]]; then
        source "$_SCRIPTS_COMMONS"
    else
        echo -e "\n    ERROR: common file [$_SCRIPTS_COMMONS] not found! Abort."
        # do not exit!
        #exit 1
    fi
fi

################################################
# enables offline SMART checks on system drives. note that smart manual says these settings
# should outlive reboots, but it's still good idea to make sure.
function enable_smart() {
    local _disk_list _disk _status msg disk_check processed_disks_count

    processed_disks_count=0
    check_progs_installed /usr/sbin/smartctl uniq sort || return 1

    _disk_list="$(sudo smartctl --scan)"
    _status="$?"
    _disk_list="$(echo "$_disk_list" | cut -d' ' -f1 | uniq | sort)"

    if [[ "$_status" -ne 0 ]]; then
        msg="smartctl --scan returned exit code [$_status]"
        err_display "$msg" "$_SELF"
        #log "$msg" "$error_log"
        #mail_error_report_and_log "$_SELF: unable to scan drives with smartctl --scan on $HOSTNAME" "$msg" "$error_log"
        return 1
    elif [[ -z "$_disk_list" ]]; then
        msg="no disks returned from [sudo smartctl --scan] command."
        err_display "$msg" "$_SELF"
        #log "$_SELF" "$error_log"
        #mail_error_report_and_log "$_SELF: no disks found using smartctl on $HOSTNAME." "$msg" "$error_log"
        return 1
    fi

    for _disk in $_disk_list; do
        disk_check="$(echo "$_disk" | sed 's/.*\///')"  # strip everything before last slash (included)
        [[ -z "$disk_check" ]] && { err_display "something went wrong with cleaning cmartctl returned disk; continuing." "$_SELF"; continue; }

        # sanity - check whether smartctl found disk is listed in /proc/partitions; if not, send error:
        if grep -Eq "\b${disk_check}\b" /proc/partitions; then
            #	-s on	enables SMART on device (off would disable); should be somewhere in machine startup script, like rc.local;
            #	-S on	enables autosave of device vendor-specific attributes
            #	-o on	turns on offline data collection every 4 hours
            sudo smartctl -s on -o on -S on "$_disk" || {
                msg="unable to enable SMART on [$_disk]"
                err_display "$msg" "$_SELF"
                #log "$msg" "$error_log"
                #mail_error_report_and_log "$_SELF: unable to enable SMART on $HOSTNAME." "$msg" "$error_log"
                # do NOT return!
            }

            let processed_disks_count+=1
        else  # err
            msg="The disk [$_disk] has been passed to me via
    [sudo smartctl --scan] command, but it cannot be located in
    [/proc/partitions]. Unmounted/mismounted volume perhaps?"
            err_display "$msg" "$_SELF"
            #log "$msg" "$error_log"
            #mail_error_report_and_log "invalid drive detected on $HOSTNAME" "$msg" "$error_log"
        fi
    done

    display_message "${_SELF}: enabled SMART for [$processed_disks_count] drives." $(( 10 * 1000 ))
}

set_perms() {
    [[ -f "$HOME/.netrc" ]] && chmod 600 -- "$(realpath -- "$HOME/.netrc")"
    [[ -d "$HOME/.ssh" ]] && chmod -R u=rwX,g=,o= -- "$(realpath -- "$HOME/.ssh")"  # sanitise ssh
}

set_keyboard_layout() {
    local layouts
    readonly layouts='ee,us'
    check_progs_installed setxkbmap || return 1
    setxkbmap -option grp:alt_shift_toggle "$layouts" || { err_display "err setting keyboard layout(s) to [$layouts]" "$_SELF"; return 1; }
}

# mopidy->ncmpcpp visualizer issue thread: https://github.com/mopidy/mopidy/issues/775
open_mpd_fifo() {
    local fifo
    readonly fifo='/tmp/mpd.fifo'

    check_progs_installed mkfifo socat || return 1
    mkfifo "$fifo" || { err_display "creating mpd fifo [$fifo] failed with $?"; return 1; }  # create fifo for mpd/mopidy outpupt to get visuals in ncmpcpp
    while :; do socat -d -d -T 1 -u UDP4-LISTEN:5555 OPEN:"$fifo"; done
}

################################################

(
    #xrandr --output DP-2 --auto --right-of DP-1 &
    check_progs_installed detect_displays.sh && detect_displays.sh
    if is_work && ! is_laptop; then
        check_progs_installed xrandr && xrandr --output DP-2 --rotate left
    fi
) &

# Load bitmap fonts:
xset +fp ~/.fonts
xset fp rehash
#sleep 1

# Set default cursor
#xsetroot -cursor_name left_ptr

# Load the Xresources database:
[[ -r ~/.Xresources ]] && { xrdb -merge ~/.Xresources || err_display "xrdb merge failed" "$_SELF"; }  # do not background!

# disable system beep:
xset -b &




# See policykit k채itati tavaliste DE-de puhul /etc/xdg/autostart/polkit-gnome....desktop-ist;
# kui ei k채ivitanud, siis andis network-manager wireless v천rku 체hendamisel permission errori:
# teine variant, kuidas soovitatakse NM permission errorist jagu saada:
# loo fail  /etc/polkit-1/localauthority/50-local.d/org.freedesktop.NetworkManager.pkla sisuga:
#[nm-applet]
#Identity=unix-group:netdev
#Action=org.freedesktop.NetworkManager.*
#ResultAny=yes
#ResultInactive=no
#ResultActive=yes

#dbus-update-activation-environment --systemd --all  # https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=842712
#/usr/lib/polkit-gnome-authentication-agent-1 &
/usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1 &

# keyring is tricky with i3; see https://wiki.archlinux.org/index.php/GNOME/Keyring#PAM_method & https://www.reddit.com/r/archlinux/comments/648dxp/using_gnomekeyring_with_i3/
eval $(/usr/bin/gnome-keyring-daemon --start --components=gpg,pkcs11,secrets,ssh)
sleep 1  # TODO potential race condition here - dunst as root sometimes not picking up config
export GNOME_KEYRING_CONTROL GNOME_KEYRING_PID GPG_AGENT_INFO SSH_AUTH_SOCK DBUS_SESSION_BUS_ADDRESS DBUS_SESSION_BUS_PID



# Secondary autostart directory, nothing important started here so okay to skip in clean for minimal session
if [[ -d $HOME/.config/autostart ]]; then
    for n in $HOME/.config/autostart/*; do
        m=$(cat "$n")
        case $m in
            *OnlyShowIn*) true
                ;;
            *)
                AUTOSTART+=("$(echo "$m" | grep -m 1 "Exec=" | sed 's/Exec=//g')")
                ;;
        esac
    done
    unset n
    unset m
fi

# System autostart directories
#if [[ -d /etc/X11/xinit/xinitrc.d ]]; then
  #for f in /etc/X11/xinit/xinitrc.d/*; do
    #AUTOSTART+=("$f")
  #done
  #unset f
#fi
if [[ -d /etc/X11/xinit/xinitrc.d ]]; then
    for f in /etc/X11/xinit/xinitrc.d/?*.sh ; do
        [ -x "$f" ] && . "$f"
    done
    unset f
fi


# TODO https://unix.stackexchange.com/questions/440044/xinitrc-set-dbus-session-bus-address/440617#440617
# suggests this should be enabled on debian, but it broke startup script for me:
#if [[ -d /etc/X11/Xsession.d ]]; then
    #for f in /etc/X11/Xsession.d/*; do
        #[ -f "$f" ] && . "$f"
    #done
    #unset f
#fi


if [[ -d /etc/xdg/autostart ]]; then
    for y in /etc/xdg/autostart/*; do
        x=$(cat "$y")
        case "$x" in
            *OnlyShowIn*) true
                # There ain't no-one in the 'verse putting "OnlyShowIn=dwm" in a .desktop file
                # Similarly, ain't no-one putting "NotShowIn=dwm" in a .desktop file. Hence, both cases are ignored
                ;;
            *)
                AUTOSTART+=("$(echo "$x" | grep -m 1 "Exec=" | sed 's/Exec=//g')")
                ;;
        esac
    done
    unset y
    unset x
fi

# Runs everything in the AUTOSTART array simultaneously without blocking startup
for x in "${AUTOSTART[@]}"; do
    eval "$x" &
    # Give it a little time to start
    sleep 0.1s
done

# Start the programs/scripts in $SESSION_STARTFILE:
if [[ -r "$SESSION_STARTFILE" ]]; then
    source "$SESSION_STARTFILE"
    # give some time before wm is launched:
    sleep 1.5
else
    if command -v rxvt-unicode; then
        rxvt-unicode &
    else
        xterm &
    fi
fi

# work-machines' specific startup logic:
if is_work; then
    set_vol 0
fi


## Start gpg-agent daemon
#if [[ -x /usr/bin/gpg-agent ]]; then
#kill $(ps ux | awk '/gpg-agent/ && !/awk/ {print $2}') >/dev/null 2>&1
#fi
#if [[ -x /usr/bin/gpg-agent ]]; then
#eval "$(/usr/bin/gpg-agent --daemon)"
#fi

# Check whether logfolder at /var/log and /data/ dir are existing:
for i in \
        "$CUSTOM_LOGDIR" \
        /data/ \
            ; do
    if [[ ! -w "$i" ]]; then
        err_display  "[$i] is not created or no write permissions granted. Do it!" "$_SELF"
    fi
done &

# Create necessary directories if don't exist:
for i in \
        /data/.rsync \
        "$_PERSISTED_TMP" \
            ; do
    if [[ ! -d "$i" ]] && ! mkdir "$i"; then
        err_display  "Tried to create required directory [$i] but mkdir failed." "$_SELF"
    fi
done &

# NOTE: after synaptic got phased out by libinput, this does not seem to be required
# anomore. YMMV.
#
# synaptics/touchpad:
# list devices:  libinput-list-devices
# list device props: xinput list-props 'SynPS/2 Synaptics TouchPad'  <-- latter arg is the device name
# set prop: 'xinput set-prop device-number option-number setting' eg xinput set-prop 'SynPS/2 Synaptics TouchPad' 297 1
#if is_laptop && check_progs_installed xinput; then
    ## OLD, synaptic-based config (pre libinput):
    ## enable tapping on synaptics touchpad:
    ##synclient TapButton1=1 TapButton2=3 TapButton3=2 || err_display "something went wrong while setting synaptics" "$_SELF"
    ##synclient PalmDetect=1 || err_display "err setting synclient palmdetect" "$_SELF"
    #true  # TODO add xinput config
#fi


#TODO: this stuff needs to be done via logrotate perhaps?
# Check the filesize in MB of logs dir:
allowed_size=20   # Max size in MB
check_max_allowed_size "$CUSTOM_LOGDIR" "$allowed_size"

set_perms &
set_keyboard_layout &
if is_native; then
    enable_smart &
    open_mpd_fifo &
fi

unset i x f m n SESSION_STARTFILE AUTOSTART _SELF allowed_size

